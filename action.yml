name: Setup PostgreSQL and PostGIS for Linux/macOS/Windows
author: Yuri Astrakhan
description: Setup PostgreSQL server and install PostGIS extension.
branding:
  icon: database
  color: purple
inputs:
  username:
    description: The username of the user to setup.
    default: postgres
    required: false
  password:
    description: The password of the user to setup.
    default: postgres
    required: false
  database:
    description: The database name to setup and grant permissions to created user.
    default: postgres
    required: false
  port:
    description: The server port to listen on.
    default: "5432"
    required: false
  rights:
    description: Space-separated list of params passed to createuser.
    default: "--createdb"
    required: false
  cached-dir:
    description: Where should the temporary downloads be placed. Used to download and cache PostGIS binary.
    default: "downloads"
    required: false
outputs:
  connection-uri:
    description: The connection URI to connect to PostgreSQL.
    value: ${{ steps.connection-uri.outputs.value }}
runs:
  using: composite
  steps:
    - name: Install PostGIS (Linux)
      if: runner.os == 'Linux'
      run: |
        # Detect installed PostgreSQL version
        PG_VERSION=$(apt list --installed | grep -E 'postgresql-[0-9.]+' | sed -rn 's/.*postgresql-([0-9.]+).*/\1/p')
        [[ "$PG_VERSION" =~ ^[0-9.]+$ ]] || (echo "Failed to detect Postgres version" && exit 1)
        echo "Detected PostgreSQL version: $PG_VERSION"
        
        # Install PostGIS
        REPO_URL="https://apt.postgresql.org/pub/repos/apt/"
        wget -qO - https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /usr/share/keyrings/postgresql.gpg >/dev/null
        echo "deb [signed-by=/usr/share/keyrings/postgresql.gpg] $REPO_URL $(lsb_release -cs)-pgdg main" | sudo tee /etc/apt/sources.list.d/pgdg.list >/dev/null
        sudo apt update
        sudo apt-get install postgresql-$PG_VERSION-postgis-3
        
        # sudo apt install curl ca-certificates gnupg
        # curl https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/apt.postgresql.org.gpg >/dev/null
        # sudo sh -c 'echo "deb https://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
        # sudo apt update        
        # sudo apt-get install postgis
      shell: bash

      # A workaround for postgis installation bug on macOS. Might not be needed in the future
    - name: Brew workaround (Mac)
      if: runner.os == 'macOS'
      run: brew link --overwrite python@3.11
      shell: bash

    - name: Install PostGIS (Mac)
      if: runner.os == 'macOS'
      run: brew install postgis
      shell: bash

    - name: Decide Postgis version (Windows)
      # Download the list of available Postgis versions, and decide which one to use
      if: runner.os == 'Windows'
      id: postgis-ver
      shell: pwsh
      run: |
        echo "PowerShell version: ${PSVersionTable.PSVersion}"
        $PG_VERSION = Split-Path $env:PGROOT -Leaf
        $postgis_page = "https://download.osgeo.org/postgis/windows/pg$PG_VERSION"
        echo "Detecting PostGIS version from $postgis_page for PostgreSQL $PG_VERSION"
        $pgis_bundle = (Invoke-WebRequest -Uri $postgis_page -ErrorAction Stop).Links.Where({$_.href -match "^postgis.*zip$"}).href
        if (!$pgis_bundle) {
          Write-Error "Could not find latest PostGIS version in $postgis_page that would match  ^postgis.*zip$  pattern"
          exit 1
        }
        $pgis_bundle = [IO.Path]::ChangeExtension($pgis_bundle, [NullString]::Value)
        $pgis_bundle_url = "$postgis_page/$pgis_bundle.zip"
        Add-Content $env:GITHUB_OUTPUT "pgis_bundle=$pgis_bundle"
        Add-Content $env:GITHUB_OUTPUT "pgis_bundle_url=$pgis_bundle_url"

    - name: Cache Postgis Download (Windows)
      if: runner.os == 'Windows'
      uses: actions/cache@v3
      id: cache-downloads
      with:
        path: ${{ inputs.cached-dir }}
        key: ${{ runner.os }}-${{ steps.postgis-ver.outputs.pgis_bundle_url }}

    - name: Download Postgis (Windows)
      if: runner.os == 'Windows' && steps.postgis-ver.outputs.cache-hit != 'true'
      shell: pwsh
      # Download Postgis bundle if not in cache
      env:
        PGIS_BUNDLE: ${{ steps.postgis-ver.outputs.pgis_bundle }}
        PGIS_BUNDLE_URL: ${{ steps.postgis-ver.outputs.pgis_bundle_url }}
      run: |
        echo "Downloading $env:PGIS_BUNDLE from $env:PGIS_BUNDLE_URL"
        $postgis_zip = "postgis.zip"
        Invoke-WebRequest $env:PGIS_BUNDLE_URL -OutFile $postgis_zip -ErrorAction Stop

        echo "Extracting ${{ inputs.cached-dir }}\$env:PGIS_BUNDLE\*"
        Remove-Item ${{ inputs.cached-dir }} -Recurse -Force -ErrorAction Ignore
        echo "Expanded $((Expand-Archive $postgis_zip -DestinationPath ${{ inputs.cached-dir }} -PassThru).count) files from $postgis_zip"
        echo "Moved $((Move-Item -Path "${{ inputs.cached-dir }}\$env:PGIS_BUNDLE\*" -Destination ${{ inputs.cached-dir }} -Force -PassThru).count) files to ${{ inputs.cached-dir }}"
        Remove-Item $postgis_zip
        if (!(Test-Path "${{ inputs.cached-dir }}\*")) {
          Write-Error "Could not find PostGIS files in ${{ inputs.cached-dir }}"
          exit 1
        }

    - name: Install Postgis (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        if (!(Test-Path "${{ inputs.cached-dir }}\*")) {
          Write-Error "Could not find PostGIS files in ${{ inputs.cached-dir }}"
          exit 1
        }
        echo "Copied $((Copy-Item -Path "${{ inputs.cached-dir }}\*" -Destination $env:PGROOT -Force -Recurse -PassThru).count) PostGIS files to $env:PGROOT"
        echo "Starting PostgreSQL and adding postgis extension"
        $env:Path = "$env:PGBIN;" + $env:Path
        & pg_ctl restart -D "$env:PGDATA"
        & pg_isready

    - name: Prerequisites
      run: |
        if [ "$RUNNER_OS" == "Linux" ]; then
          echo "$(pg_config --bindir)" >> $GITHUB_PATH
        elif [ "$RUNNER_OS" == "Windows" ]; then
          echo "$PGBIN" >> $GITHUB_PATH
          echo "PQ_LIB_DIR=$PGROOT\lib" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Setup and start PostgreSQL
      run: |
        export PGDATA="$RUNNER_TEMP/pgdata"
        pg_ctl init --options="--encoding=UTF-8 --locale=en_US.UTF-8"

        # Forbid creating unix sockets since they are created by default in the
        # directory we don't have permissions to.
        echo "unix_socket_directories = ''" >> "$PGDATA/postgresql.conf"
        echo "port = ${{ inputs.port }}" >> "$PGDATA/postgresql.conf"
        pg_ctl start

        # Both PGHOST and PGUSER are used by PostgreSQL tooling such as 'psql'
        # or 'createuser'. Since PostgreSQL data has been re-setup, we cannot
        # rely on defaults anymore.
        #
        # PGHOST is required for Linux and macOS since they default to unix
        # sockets, and we have turned them off.
        #
        # PGUSER is required for Windows since default the tooling's default
        # user is 'postgres', while 'pg_ctl init' creates one with the name of
        # the current user.
        echo "PGHOST=localhost" >> $GITHUB_ENV
        echo "PGUSER=${USER:-$USERNAME}" >> $GITHUB_ENV
        echo "PGPORT=${{ inputs.port }}" >> $GITHUB_ENV
        echo "PGDATABASE=${{ inputs.database }}" >> $GITHUB_ENV
        echo "PGPASSWORD=${{ inputs.password }}" >> $GITHUB_ENV
      shell: bash

    - name: Setup PostgreSQL user and database
      run: |
        createuser ${{ inputs.rights }} ${{ inputs.username }}

        if [ "${{ inputs.database }}" != "postgres" ]; then
          createdb -O ${{ inputs.username }} ${{ inputs.database }}
        fi

        psql -v ON_ERROR_STOP=1 -c "ALTER USER ${{ inputs.username }} PASSWORD '${{ inputs.password }}';"
        psql -v ON_ERROR_STOP=1 -c "CREATE EXTENSION IF NOT EXISTS postgis;" "${{ inputs.database }}"
      shell: bash

    - name: Expose connection URI
      run: |
        CONNECTION_URI="postgresql://${{ inputs.username }}:${{ inputs.password }}@localhost:${{inputs.port}}/${{ inputs.database }}"
        echo "value=$CONNECTION_URI" >> $GITHUB_OUTPUT
      shell: bash
      id: connection-uri
