name: Setup PostgreSQL and PostGIS for Linux/macOS/Windows
author: Yuri Astrakhan
description: Setup PostgreSQL server and install PostGIS extension.
branding:
  icon: database
  color: purple
inputs:
  username:
    description: The username of the user to setup.
    default: postgres
    required: false
  password:
    description: The password of the user to setup.
    default: postgres
    required: false
  database:
    description: The database name to setup and grant permissions to created user.
    default: postgres
    required: false
  port:
    description: The server port to listen on.
    default: "5432"
    required: false
  cached-dir:
    description: Where should the temporary downloads be placed. Used to download and cache PostGIS binary.
    default: "downloads"
    required: false
outputs:
  connection-uri:
    description: The connection URI to connect to PostgreSQL.
    value: ${{ steps.set-outputs.outputs.connection-uri }}
  service-name:
    description: The service name with connection parameters.
    value: ${{ steps.set-outputs.outputs.service-name }}
runs:
  using: composite
  steps:
    - name: Install PostGIS (Linux)
      if: runner.os == 'Linux'
      run: |
        # Detect installed PostgreSQL version
        PG_VERSION=$(apt list --installed | grep -E 'postgresql-[0-9.]+' | sed -rn 's/.*postgresql-([0-9.]+).*/\1/p')
        [[ "$PG_VERSION" =~ ^[0-9.]+$ ]] || (echo "Failed to detect Postgres version" && exit 1)
        echo "Detected PostgreSQL version: $PG_VERSION"
        
        # Install PostGIS
        REPO_URL="https://apt.postgresql.org/pub/repos/apt/"
        wget -qO - https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /usr/share/keyrings/postgresql.gpg >/dev/null
        echo "deb [signed-by=/usr/share/keyrings/postgresql.gpg] $REPO_URL $(lsb_release -cs)-pgdg main" | sudo tee /etc/apt/sources.list.d/pgdg.list >/dev/null
        sudo apt update
        sudo apt-get install postgresql-$PG_VERSION-postgis-3
        
        # sudo apt install curl ca-certificates gnupg
        # curl https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/apt.postgresql.org.gpg >/dev/null
        # sudo sh -c 'echo "deb https://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
        # sudo apt update        
        # sudo apt-get install postgis
      shell: bash

    - name: Install PostGIS (Mac)
      if: runner.os == 'macOS'
      run: brew install postgis || true
      shell: bash

      # A workaround for postgis installation bug on macOS. Might not be needed in the future
    - name: Brew workaround 2 (Mac)
      if: runner.os == 'macOS'
      run: brew link --overwrite python@3.11
      shell: bash

    - name: Decide Postgis version (Windows)
      # Download the list of available Postgis versions, and decide which one to use
      if: runner.os == 'Windows'
      id: postgis-ver
      shell: pwsh
      run: |
        echo "PowerShell version: ${PSVersionTable.PSVersion}"
        $PG_VERSION = Split-Path $env:PGROOT -Leaf
        $postgis_page = "https://download.osgeo.org/postgis/windows/pg$PG_VERSION"
        echo "Detecting PostGIS version from $postgis_page for PostgreSQL $PG_VERSION"
        $pgis_bundle = (Invoke-WebRequest -Uri $postgis_page -ErrorAction Stop).Links.Where({$_.href -match "^postgis.*zip$"}).href
        if (!$pgis_bundle) {
          Write-Error "Could not find latest PostGIS version in $postgis_page that would match  ^postgis.*zip$  pattern"
          exit 1
        }
        $pgis_bundle = [IO.Path]::ChangeExtension($pgis_bundle, [NullString]::Value)
        $pgis_bundle_url = "$postgis_page/$pgis_bundle.zip"
        Add-Content $env:GITHUB_OUTPUT "pgis_bundle=$pgis_bundle"
        Add-Content $env:GITHUB_OUTPUT "pgis_bundle_url=$pgis_bundle_url"

    - name: Cache Postgis Download (Windows)
      if: runner.os == 'Windows'
      uses: actions/cache@v3
      id: cache-downloads
      with:
        path: ${{ inputs.cached-dir }}
        key: ${{ runner.os }}-${{ steps.postgis-ver.outputs.pgis_bundle_url }}

    - name: Download Postgis (Windows)
      if: runner.os == 'Windows' && steps.postgis-ver.outputs.cache-hit != 'true'
      shell: pwsh
      # Download Postgis bundle if not in cache
      env:
        PGIS_BUNDLE: ${{ steps.postgis-ver.outputs.pgis_bundle }}
        PGIS_BUNDLE_URL: ${{ steps.postgis-ver.outputs.pgis_bundle_url }}
      run: |
        echo "Downloading $env:PGIS_BUNDLE from $env:PGIS_BUNDLE_URL"
        $postgis_zip = "postgis.zip"
        Invoke-WebRequest $env:PGIS_BUNDLE_URL -OutFile $postgis_zip -ErrorAction Stop

        echo "Extracting ${{ inputs.cached-dir }}\$env:PGIS_BUNDLE\*"
        Remove-Item ${{ inputs.cached-dir }} -Recurse -Force -ErrorAction Ignore
        echo "Expanded $((Expand-Archive $postgis_zip -DestinationPath ${{ inputs.cached-dir }} -PassThru).count) files from $postgis_zip"
        echo "Moved $((Move-Item -Path "${{ inputs.cached-dir }}\$env:PGIS_BUNDLE\*" -Destination ${{ inputs.cached-dir }} -Force -PassThru).count) files to ${{ inputs.cached-dir }}"
        Remove-Item $postgis_zip
        if (!(Test-Path "${{ inputs.cached-dir }}\*")) {
          Write-Error "Could not find PostGIS files in ${{ inputs.cached-dir }}"
          exit 1
        }

    - name: Install Postgis (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        if (!(Test-Path "${{ inputs.cached-dir }}\*")) {
          Write-Error "Could not find PostGIS files in ${{ inputs.cached-dir }}"
          exit 1
        }
        echo "Copied $((Copy-Item -Path "${{ inputs.cached-dir }}\*" -Destination $env:PGROOT -Force -Recurse -PassThru).count) PostGIS files to $env:PGROOT"
        echo "Starting PostgreSQL and adding postgis extension"
        $env:Path = "$env:PGBIN;" + $env:Path
        & pg_ctl restart -D "$env:PGDATA"
        & pg_isready

    - name: Prerequisites
      run: |
        if [ "$RUNNER_OS" == "Linux" ]; then
          echo "$(pg_config --bindir)" >> $GITHUB_PATH
        elif [ "$RUNNER_OS" == "Windows" ]; then
          echo "$PGBIN" >> $GITHUB_PATH
          echo "PQ_LIB_DIR=$PGROOT\lib" >> $GITHUB_ENV

          # The Windows runner has some PostgreSQL environment variables set
          # that may confuse users since they may be irrelevant to the
          # PostgreSQL server we're using.
          for name in "PGROOT" "PGDATA" "PGBIN" "PGUSER" "PGPASSWORD"; do
            echo "$name=" >> $GITHUB_ENV
          done
        elif [ "$RUNNER_OS" == "macOS" ]; then
          case "$(sw_vers -productVersion)" in
            13.*|14.*)
              # Unfortunately, the macOS 13 runner image doesn't come w/
              # pre-installed PostgreSQL server.
              export HOMEBREW_NO_INSTALLED_DEPENDENTS_CHECK=1
              export HOMEBREW_NO_INSTALL_CLEANUP=1
              export HOMEBREW_NO_INSTALL_UPGRADE=1
              brew install --skip-post-install postgresql@14
              ;;
          esac
        fi
      shell: bash

    - name: Setup and start PostgreSQL
      run: |
        export PGDATA="$RUNNER_TEMP/pgdata"
        export PWFILE="$RUNNER_TEMP/pwfile"

        DEFAULT_ENCODING="UTF-8"
        DEFAULT_LOCALE="en_US.$DEFAULT_ENCODING"

        # Unfortunately, Windows Server 2019 doesn't understand locale
        # specified in the format defined by the POSIX standard, i.e.
        # <language>_<country>.<encoding>. Therefore, we have to convert it
        # into something it can swallow, i.e. <language>-<country>.
        if [[ "$RUNNER_OS" == "Windows" && "$(wmic os get Caption)" == *"2019"* ]]; then
          DEFAULT_LOCALE="${DEFAULT_LOCALE%%.*}"
          DEFAULT_LOCALE="${DEFAULT_LOCALE//_/-}"
        fi

        # Unfortunately 'initdb' could only receive a password via file on disk
        # or prompt to enter on. Prompting is not an option since we're running
        # in non-interactive mode.
        echo '${{ inputs.password }}' > $PWFILE

        # There are couple of reasons why we need to create a new PostgreSQL
        # database cluster. First and foremost, we have to create a superuser
        # with provided credentials. Second, we want the PostgreSQL client
        # applications [1] to be available for execution without
        # run-from-another-user dances. Third, we want to make sure that
        # settings are the same between operating systems and aren't changed by
        # package vendors.
        #
        # [1] https://www.postgresql.org/docs/15/reference-client.html
        initdb \
          --username="${{ inputs.username }}" \
          --pwfile="$PWFILE" \
          --auth="scram-sha-256" \
          --encoding="$DEFAULT_ENCODING" \
          --locale="$DEFAULT_LOCALE" \
          --no-instructions

        # Do not create unix sockets since they are created by default in the
        # directory we have no permissions to (owned by system postgres user).
        echo "unix_socket_directories = ''" >> "$PGDATA/postgresql.conf"
        echo "port = ${{ inputs.port }}" >> "$PGDATA/postgresql.conf"
        pg_ctl start

        # Save required connection parameters for created superuser to the
        # connection service file [1]. This allows using these connection
        # parameters by setting 'PGSERVICE' environment variable or by
        # requesting them via connection string.
        #
        # HOST is required for Linux/macOS because these OS-es default to unix
        # sockets but we turned them off.
        #
        # PORT, USER, PASSWORD and DBNAME are required because they could be
        # parametrized via action input parameters.
        #
        # [1] https://www.postgresql.org/docs/15/libpq-pgservice.html
        cat <<EOF > "$PGDATA/pg_service.conf"
        [${{ inputs.username }}]
        host=localhost
        port=${{ inputs.port }}
        user=${{ inputs.username }}
        password=${{ inputs.password }}
        dbname=${{ inputs.database }}
        EOF
        echo "PGSERVICEFILE=$PGDATA/pg_service.conf" >> $GITHUB_ENV
      shell: bash

    - name: Setup PostgreSQL database
      run: |
        # The 'postgres' database is a pre-created database meant for use by
        # users, utilities and third party applications. There's no way to
        # parametrize the name, so all we can do is to avoid creating a
        # database if provided name is 'postgres'.
        if [ "${{ inputs.database }}" != "postgres" ]; then
          createdb -O "${{ inputs.username }}" "${{ inputs.database }}"
        fi
      env:
        PGSERVICE: ${{ inputs.username }}
      shell: bash

    - name: Set action outputs
      run: |
        CONNECTION_URI="postgresql://${{ inputs.username }}:${{ inputs.password }}@localhost:${{ inputs.port }}/${{ inputs.database }}"

        echo "connection-uri=$CONNECTION_URI" >> $GITHUB_OUTPUT
        echo "service-name=${{ inputs.username }}" >> $GITHUB_OUTPUT
      shell: bash
      id: set-outputs

    - name: Enable PostGIS extension
      run: psql -v ON_ERROR_STOP=1 -c "CREATE EXTENSION IF NOT EXISTS postgis;" "${{ inputs.database }}"
      shell: bash
